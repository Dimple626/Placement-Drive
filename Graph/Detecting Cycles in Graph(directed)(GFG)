class Solution {
    public boolean isCyclic(int v, int[][] edges) {
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < v; i++) {
            adj.add(new ArrayList<>());
        }

        // make the graph directed
        for (int[] edge : edges) {
            adj.get(edge[0]).add(edge[1]);
        }

        int[] vis = new int[v];

        for (int i = 0; i < v; i++) {
            if (vis[i] == 0) {
                if (dfs(i, adj, vis)) return true;
            }
        }
        return false;
    }

    private boolean dfs(int node, ArrayList<ArrayList<Integer>> adj, int[] vis) {
        vis[node] = 1; // visiting

        for (int nei : adj.get(node)) {
            if (vis[nei] == 0) {
                if (dfs(nei, adj, vis)) return true;
            } else if (vis[nei] == 1) {
                // back edge found â†’ cycle detected
                return true;
            }
        }
        vis[node] = 2; // fully processed
        return false;
    }
}


/////////by Dfs approach//////////////


class Solution {
    public boolean isCyclic(int v, int[][] edges) {
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < v; i++) {
            adj.add(new ArrayList<>());
        }

        // make the graph directed
        for (int[] edge : edges) {
            adj.get(edge[0]).add(edge[1]);
        }
        int[] vis=new int[v];
        int[] pathvis=new int[v];
        for(int i=0;i<v;i++){
            if(vis[i]==0){
                if(dfscheck(i,adj,vis,pathvis)==true){
                    return true;
                }
            }
        }
       
       return false;
    }
    private boolean dfscheck(int node,ArrayList<ArrayList<Integer>> adj,int[] vis,
    int[] pathvis){
        vis[node]=1;
        pathvis[node]=1;
        for(int a:adj.get(node)){
            if(vis[a]==0){
                if(dfscheck(a,adj,vis,pathvis)==true){
                    return true;
                }
            }else if(pathvis[a]==1){
                return true;
            }
        }
        pathvis[node]=0;
        return false;
    }
}

//// BY TOPOLOGICAL SORT////


class Solution {
    public boolean isCyclic(int v, int[][] edges) {
       ArrayList<ArrayList<Integer>> adj=new ArrayList<>();
        for(int i=0;i<v;i++){
            adj.add(new ArrayList<>());
        }
        for(int[] edge:edges){
            adj.get(edge[0]).add(edge[1]);
        }
        int[] indegree=new int[v];
        for(int i=0;i<v;i++){
            for(int it:adj.get(i)){
                indegree[it]++;
            }
        }
        Queue<Integer> q=new LinkedList<>();
        for(int i=0;i<v;i++){
            if(indegree[i]==0){
                q.add(i);
            }
        }
        int i=0;
        int cnt=0;
        while(!q.isEmpty()){
            int node=q.peek();
            q.remove();
            cnt++;
            for(int it:adj.get(node)){
                indegree[it]--;
                if(indegree[it]==0){
                q.add(it);
            }
            }
        }
        if(cnt==v) return false;
      
        return true;
    }
}
